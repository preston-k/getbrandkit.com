'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Stream = _interopDefault(require('stream'));
var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));
var child_process = require('child_process');

// node_modules/es-tostring/index.mjs
function toString(obj) {
  return Object.prototype.toString.call(obj)
}

// node_modules/es-hasown/index.mjs

// node_modules/es-is/bool.js

// node_modules/es-is/infinite.js

// node_modules/es-is/number.js

// node_modules/es-is/array-like.js

// node_modules/es-is/array.js
// Generated by CoffeeScript 1.12.5
var isArray;

var isArray$1 = isArray = Array.isArray || function(value) {
  return toString(value) === '[object Array]';
};

// node_modules/es-is/function.js
// Generated by CoffeeScript 1.12.5
var isFunction;

var isFunction$1 = isFunction = function(value) {
  var str;
  if (typeof window !== 'undefined' && value === window.alert) {
    return true;
  }
  str = toString(value);
  return str === '[object Function]' || str === '[object GeneratorFunction]' || str === '[object AsyncFunction]';
};

// node_modules/es-is/object.js
// Generated by CoffeeScript 1.12.5
var isObject;

var isObject$1 = isObject = function(value) {
  return toString(value) === '[object Object]';
};

// node_modules/es-is/arguments.js

// node_modules/es-is/async-function.js

// node_modules/es-is/string.js
// Generated by CoffeeScript 1.12.5
var isString;

var isString$1 = isString = function(value) {
  return toString(value) === '[object String]';
};

// node_modules/es-is/base64.js

// node_modules/es-is/date.js

// node_modules/es-is/utils.js

// node_modules/es-is/decimal.js

// node_modules/es-is/defined.js

// node_modules/es-is/divisible-by.js

// node_modules/es-is/element.js

// node_modules/es-is/empty-arguments.js

// node_modules/es-is/empty-array.js

// node_modules/es-is/empty.js

// node_modules/es-is/equal.js

// node_modules/es-is/error.js

// node_modules/es-is/even.js

// node_modules/es-is/false.js

// node_modules/es-is/generator-function.js

// node_modules/es-is/generator.js

// node_modules/es-is/ge.js

// node_modules/es-is/gt.js

// node_modules/es-is/hash.js

// node_modules/es-is/hex.js

// node_modules/es-is/hosted.js

// node_modules/es-is/instanceof.js

// node_modules/es-is/integer.js

// node_modules/es-is/le.js

// node_modules/es-is/lt.js

// node_modules/es-is/max.js

// node_modules/es-is/min.js

// node_modules/es-is/nan.js

// node_modules/es-is/null.js

// node_modules/es-is/odd.js

// node_modules/es-is/primitive.js

// node_modules/es-is/promise.js
// Generated by CoffeeScript 1.12.5
var isPromise;

var isPromise$1 = isPromise = function(value) {
  return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';
};

// node_modules/es-is/regexp.js

// node_modules/es-is/symbol.js

// node_modules/es-is/true.js

// node_modules/es-is/type.js

// node_modules/es-is/undefined.js

// node_modules/es-is/valid-date.js

// node_modules/es-is/within.js

// node_modules/es-is/index.mjs

// src/spawn/buffer-stream.coffee
var BufferStream;

BufferStream = class BufferStream extends Stream {
  constructor() {
    super();
    this.buffer = '';
    this.writable = true;
  }

  write(data) {
    return this.buffer += data;
  }

  end(data) {
    if (arguments.length) {
      this.write(data);
    }
    return this.writable = false;
  }

  destroy() {
    return this.writable = false;
  }

  toString() {
    return this.buffer;
  }

};

var BufferStream$1 = BufferStream;

// node_modules/jsonify/lib/parse.js
var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error$1 = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error$1("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error$1("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error$1("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error$1("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error$1("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error$1('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error$1("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

var parse = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error$1("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};

// node_modules/jsonify/lib/stringify.js
var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

var stringify = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};

//  commonjs-proxy:/Users/zk/dev/zeekay/executive/node_modules/jsonify/lib/parse.js

//  commonjs-proxy:/Users/zk/dev/zeekay/executive/node_modules/jsonify/lib/stringify.js

// node_modules/jsonify/index.js
var parse$1 = parse;
var stringify$1 = stringify;

var jsonify = {
	parse: parse$1,
	stringify: stringify$1
};

// node_modules/array-map/index.js
var arrayMap = function (xs, f) {
    if (xs.map) return xs.map(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = xs[i];
        if (hasOwn$1.call(xs, i)) res.push(f(x, i, xs));
    }
    return res;
};

var hasOwn$1 = Object.prototype.hasOwnProperty;

// node_modules/array-filter/index.js
/**
 * Array#filter.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @return {Array}
 */

var arrayFilter = function (arr, fn) {
  if (arr.filter) return arr.filter(fn);
  var ret = [];
  for (var i = 0; i < arr.length; i++) {
    if (!hasOwn$2.call(arr, i)) continue;
    if (fn(arr[i], i, arr)) ret.push(arr[i]);
  }
  return ret;
};

var hasOwn$2 = Object.prototype.hasOwnProperty;

// node_modules/array-reduce/index.js
var hasOwn$3 = Object.prototype.hasOwnProperty;

var arrayReduce = function (xs, f, acc) {
    var hasAcc = arguments.length >= 3;
    if (hasAcc && xs.reduce) return xs.reduce(f, acc);
    if (xs.reduce) return xs.reduce(f);
    
    for (var i = 0; i < xs.length; i++) {
        if (!hasOwn$3.call(xs, i)) continue;
        if (!hasAcc) {
            acc = xs[i];
            hasAcc = true;
            continue;
        }
        acc = f(acc, xs[i], i);
    }
    return acc;
};

//  commonjs-proxy:/Users/zk/dev/zeekay/executive/node_modules/jsonify/index.js

//  commonjs-proxy:/Users/zk/dev/zeekay/executive/node_modules/array-map/index.js

//  commonjs-proxy:/Users/zk/dev/zeekay/executive/node_modules/array-filter/index.js

//  commonjs-proxy:/Users/zk/dev/zeekay/executive/node_modules/array-reduce/index.js

// node_modules/shell-quote/index.js
var json = typeof JSON !== undefined ? JSON : jsonify;




var quote$1 = function (xs) {
    return arrayMap(xs, function (s) {
        if (s && typeof s === 'object') {
            return s.op.replace(/(.)/g, '\\$1');
        }
        else if (/["\s]/.test(s) && !/'/.test(s)) {
            return "'" + s.replace(/(['\\])/g, '\\$1') + "'";
        }
        else if (/["'\s]/.test(s)) {
            return '"' + s.replace(/(["\\$`!])/g, '\\$1') + '"';
        }
        else {
            return String(s).replace(/([#!"$&'()*,:;<=>?@\[\\\]^`{|}])/g, '\\$1'); 
        }
    }).join(' ');
};

var CONTROL = '(?:' + [
    '\\|\\|', '\\&\\&', ';;', '\\|\\&', '[&;()|<>]'
].join('|') + ')';
var META = '|&;()<> \\t';
var BAREWORD = '(\\\\[\'"' + META + ']|[^\\s\'"' + META + '])+';
var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
var DOUBLE_QUOTE = '\'((\\\\\'|[^\'])*?)\'';

var TOKEN = '';
for (var i = 0; i < 4; i++) {
    TOKEN += (Math.pow(16,8)*Math.random()).toString(16);
}

var parse_1 = function (s, env, opts) {
    var mapped = parse$2(s, env, opts);
    if (typeof env !== 'function') return mapped;
    return arrayReduce(mapped, function (acc, s) {
        if (typeof s === 'object') return acc.concat(s);
        var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));
        if (xs.length === 1) return acc.concat(xs[0]);
        return acc.concat(arrayMap(arrayFilter(xs, Boolean), function (x) {
            if (RegExp('^' + TOKEN).test(x)) {
                return json.parse(x.split(TOKEN)[1]);
            }
            else return x;
        }));
    }, []);
};

function parse$2 (s, env, opts) {
    var chunker = new RegExp([
        '(' + CONTROL + ')', // control chars
        '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'
    ].join('|'), 'g');
    var match = arrayFilter(s.match(chunker), Boolean);
    var commented = false;

    if (!match) return [];
    if (!env) env = {};
    if (!opts) opts = {};
    return arrayMap(match, function (s, j) {
        if (commented) {
            return;
        }
        if (RegExp('^' + CONTROL + '$').test(s)) {
            return { op: s };
        }

        // Hand-written scanner/parser for Bash quoting rules:
        //
        //  1. inside single quotes, all characters are printed literally.
        //  2. inside double quotes, all characters are printed literally
        //     except variables prefixed by '$' and backslashes followed by
        //     either a double quote or another backslash.
        //  3. outside of any quotes, backslashes are treated as escape
        //     characters and not printed (unless they are themselves escaped)
        //  4. quote context can switch mid-token if there is no whitespace
        //     between the two quote contexts (e.g. all'one'"token" parses as
        //     "allonetoken")
        var SQ = "'";
        var DQ = '"';
        var DS = '$';
        var BS = opts.escape || '\\';
        var quote = false;
        var esc = false;
        var out = '';
        var isGlob = false;

        for (var i = 0, len = s.length; i < len; i++) {
            var c = s.charAt(i);
            isGlob = isGlob || (!quote && (c === '*' || c === '?'));
            if (esc) {
                out += c;
                esc = false;
            }
            else if (quote) {
                if (c === quote) {
                    quote = false;
                }
                else if (quote == SQ) {
                    out += c;
                }
                else { // Double quote
                    if (c === BS) {
                        i += 1;
                        c = s.charAt(i);
                        if (c === DQ || c === BS || c === DS) {
                            out += c;
                        } else {
                            out += BS + c;
                        }
                    }
                    else if (c === DS) {
                        out += parseEnvVar();
                    }
                    else {
                        out += c;
                    }
                }
            }
            else if (c === DQ || c === SQ) {
                quote = c;
            }
            else if (RegExp('^' + CONTROL + '$').test(c)) {
                return { op: s };
            }
            else if (RegExp('^#$').test(c)) {
                commented = true;
                if (out.length){
                    return [out, { comment: s.slice(i+1) + match.slice(j+1).join(' ') }];
                }
                return [{ comment: s.slice(i+1) + match.slice(j+1).join(' ') }];
            }
            else if (c === BS) {
                esc = true;
            }
            else if (c === DS) {
                out += parseEnvVar();
            }
            else out += c;
        }

        if (isGlob) return {op: 'glob', pattern: out};

        return out;

        function parseEnvVar() {
            i += 1;
            var varend, varname;
            //debugger
            if (s.charAt(i) === '{') {
                i += 1;
                if (s.charAt(i) === '}') {
                    throw new Error("Bad substitution: " + s.substr(i - 2, 3));
                }
                varend = s.indexOf('}', i);
                if (varend < 0) {
                    throw new Error("Bad substitution: " + s.substr(i));
                }
                varname = s.substr(i, varend - i);
                i = varend;
            }
            else if (/[*@#?$!_\-]/.test(s.charAt(i))) {
                varname = s.charAt(i);
                i += 1;
            }
            else {
                varend = s.substr(i).match(/[^\w\d_]/);
                if (!varend) {
                    varname = s.substr(i);
                    i = s.length;
                } else {
                    varname = s.substr(i, varend.index);
                    i += varend.index - 1;
                }
            }
            return getVar(null, '', varname);
        }
    })
    // finalize parsed aruments
    .reduce(function(prev, arg){
        if (arg === undefined){
            return prev;
        }
        return prev.concat(arg);
    },[]);

    function getVar (_, pre, key) {
        var r = typeof env === 'function' ? env(key) : env[key];
        if (r === undefined) r = '';

        if (typeof r === 'object') {
            return pre + TOKEN + json.stringify(r) + TOKEN;
        }
        else return pre + r;
    }
}

var shellQuote = {
	quote: quote$1,
	parse: parse_1
};

// src/spawn/shell-builtins.coffee
var shellBuiltins;

var builtins = shellBuiltins = {
  // Bourne Shell builtins
  ':': true,
  '.': true,
  break: true,
  cd: true,
  continue: true,
  eval: true,
  exec: true,
  exit: true,
  export: true,
  getopts: true,
  hash: true,
  pwd: true,
  readonly: true,
  return: true,
  shift: true,
  test: true,
  times: true,
  trap: true,
  umask: true,
  unset: true,
  // Bash shell builtins
  alias: true,
  bind: true,
  builtin: true,
  caller: true,
  command: true,
  declare: true,
  echo: true,
  enable: true,
  help: true,
  let: true,
  local: true,
  logout: true,
  mapfile: true,
  printf: true,
  read: true,
  readarray: true,
  source: true,
  type: true,
  typeset: true,
  ulimit: true,
  unalias: true
};

// src/spawn/parse.coffee
var isWin, parse$3, parseObject, parseShell, parseString, shellRequired, unShellQuote, winHacks;

isWin = /^win/.test(process.platform);

// Convert objects in shell-quote results back into string arguments
unShellQuote = function(args) {
  var a, args_, i, len;
  args_ = [];
  for (i = 0, len = args.length; i < len; i++) {
    a = args[i];
    if (isString$1(a)) {
      args_.push(a);
    } else {
      if (a.op === 'glob') {
        args_.push(a.pattern);
      } else {
        args_.push(a.op);
      }
    }
  }
  return args_;
};

// Parse string containing shell command
parseShell = function(s, env, first = true) {
  var args, cmd, foundEnv, k, v;
  args = shellQuote.parse(s, env);
  // Grab command (usually first argument)
  cmd = args.shift();
  while (~cmd.indexOf('=')) {
    // Found env var i.e., FOO=1 echo $FOO
    foundEnv = true;
    // Update env object
    [k, v] = cmd.split('=', 2);
    env[k] = v;
    // Grab next arg, see if it's a command
    cmd = args.shift();
  }
  // Re-parse w/o inline env variables if any discovered
  if (first && foundEnv) {
    return parseShell(s, env, false);
  }
  return [cmd, args, env];
};

// Parse cmd, args, env from string
parseString = function(s, opts) {
  var args, cmd, env;
  env = Object.assign({}, process.env, opts.env);
  return [cmd, args, env] = parseShell(s, env);
};

// Parse cmd, args, env from object
parseObject = function(obj, opts) {
  var args, cmd, env, ref;
  cmd = obj.cmd;
  args = (ref = obj.args) != null ? ref : [];
  env = Object.assign({}, process.env, opts.env, obj.env);
  return [cmd, args, env];
};

// Check for any operators or glob patterns
shellRequired = function(cmd, args) {
  var arg, i, len;
  if (builtins[cmd]) {
    return true;
  }
  for (i = 0, len = args.length; i < len; i++) {
    arg = args[i];
    if (!isString$1(arg)) {
      return true;
    }
  }
  return false;
};

// Couple of hacks to ensure commands run smoothly on Windows
winHacks = function(cmd, args) {
  var cmdfile;
  cmd = path.normalize(cmd);
  cmdfile = cmd + '.cmd';
  if (fs.existsSync(cmdfile)) {
    // Use .cmd version of command if it exists
    cmd = cmdfile;
  }
  // Setup arguments for cmd.exe and use that as executable
  args = ['/c', cmd].concat(args);
  cmd = 'cmd.exe';
  return [cmd, args];
};

// Parse cmd, args, env from string or object
var parse$4 = parse$3 = function(cmdArgs, opts = {}) {
  var args, cmd, env;
  // Handle string, object style cmd+args
  if (isString$1(cmdArgs)) {
    [cmd, args, env] = parseString(cmdArgs, opts);
  } else if (isObject$1(cmdArgs)) {
    [cmd, args, env] = parseObject(cmdArgs, opts);
  } else {
    throw new Error(`Unable to parse command '${cmdArgs}'`);
  }
  // Detect if shell is required and stringify args correctly
  if (shellRequired(cmd, args)) {
    if (opts.shell == null) {
      opts.shell = true;
    }
    args = unShellQuote(args);
  }
  if (isWin) {
    // Apply hacks to work around Windows oddities if necessary
    [cmd, args] = winHacks(cmd, args);
  }
  // Our normalized cmd, args and opts
  return [cmd, args, opts];
};

// src/utils.coffee
// Log error
var logError = function(err) {
  if ((err.code === 'ENOENT') && /^spawn/.test(err.syscall)) {
    console.error(`Error: ${err.code}, ${err.syscall}`);
    return console.error(`Make sure '${err.cmd}' exists and is executable.`);
  }
};

// Run command exactly once
var once = function(fn) {
  var ran, result;
  ran = false;
  result = null;
  return function() {
    if (ran) {
      return result;
    }
    ran = true;
    result = fn.apply(this, arguments);
    fn = null;
    return result;
  };
};

// Merge stdout, stderr, status into results object
var mergeResult = function(stdout, stderr, status, object) {
  var ret;
  ret = object != null ? object : {};
  if (ret.status == null) {
    ret.status = status;
  }
  if (ret.stderr == null) {
    ret.stderr = stderr;
  }
  if (ret.stdout == null) {
    ret.stdout = stdout;
  }
  return ret;
};

// src/spawn/async.coffee
var async;

var async$1 = async = function(cmd, opts, cb) {
  var args, child, done, exit, ref, ref1, ref2, stderr, stdout;
  [cmd, args, opts] = parse$4(cmd, opts);
  stderr = new BufferStream$1();
  stdout = new BufferStream$1();
  child = child_process.spawn(cmd, args, {
    cwd: opts.cwd,
    env: opts.env,
    argv0: opts.argv0,
    stdio: (ref = opts.stdio) != null ? ref : [0, 'pipe', 'pipe'],
    detached: opts.detached,
    uid: opts.uid,
    gid: opts.gid,
    shell: opts.shell
  });
  child.setMaxListeners(0);
  child.stdout.setEncoding((ref1 = opts.encoding) != null ? ref1 : 'utf8');
  child.stderr.setEncoding((ref2 = opts.encoding) != null ? ref2 : 'utf8');
  // Buffer stderr, stdout
  if (!opts.interactive) {
    child.stdout.pipe(stdout);
    child.stderr.pipe(stderr);
  }
  // Echo out as well
  if (!opts.quiet) {
    child.stdout.pipe(process.stdout);
    child.stderr.pipe(process.stderr);
  }
  done = once(function(err, status) {
    stdout.destroy();
    stderr.destroy();
    child.kill();
    stdout = stdout.toString();
    stderr = stderr.toString();
    if (err != null) {
      err.cmd = cmd;
      err.args = args;
      err.stdout = stdout;
      err.stderr = stderr;
      err.status = status;
      if (!opts.quiet) {
        logError(err);
      }
    }
    return cb(err, stdout, stderr, status);
  });
  exit = once(function(status, signal) {
    var err;
    err = null;
    if (status !== 0) {
      err = new Error(`Command failed, '${cmd}' exited with status ${status}`);
      err.signal = signal;
    }
    return done(err, status);
  });
  // Close fires after exit so we are relying on it for now.
  child.on('close', exit);
  // child.on 'exit', exit
  child.on('error', done);
  return child;
};

// src/spawn/sync.coffee
var sync;

var sync$1 = sync = function(cmd, opts, cb) {
  var args, error, output, pid, ref, ref1, signal, status, stderr, stdout;
  [cmd, args, opts] = parse$4(cmd, opts);
  ({pid, output, stdout, stderr, status, signal, error} = child_process.spawnSync(cmd, args, {
    cwd: opts.cwd,
    input: opts.input,
    stdio: (ref = opts.stdio) != null ? ref : [0, 'pipe', 'pipe'],
    env: opts.env,
    uid: opts.uid,
    gid: opts.gid,
    timeout: opts.timeout,
    killSignal: opts.killSignal,
    maxBuffer: opts.maxBuffer,
    encoding: (ref1 = opts.encoding) != null ? ref1 : 'utf8'
  }));
  if (!opts.quiet) {
    process.stdout.write(stdout);
    process.stderr.write(stderr);
  }
  if ((error == null) && status !== 0) {
    error = new Error(`Command failed, '${cmd}' exited with status ${status}`);
  }
  if (error != null) {
    error.status = status;
    error.pid = pid;
    error.signal = signal;
    error.stderr = stderr;
    error.stdout = stdout;
    if (!opts.quiet) {
      logError(error);
    }
  }
  cb(error, stdout, stderr, status);
  return {
    status: status,
    stderr: stderr,
    stdout: stdout,
    error: error
  };
};

// src/flow/parallel.coffee
var parallel;

// Execute commands in parallel
var parallel$1 = parallel = function(fn, cmds, opts, cb) {
  var append, cmd, done, errAll, errors, object, outAll, todo;
  outAll = '';
  errAll = '';
  errors = [];
  todo = cmds.length;
  if (cmds.length && isArray$1(cmds[0])) {
    object = {};
  } else {
    object = null;
  }
  append = function(key, res = {}) {
    var error$$1, status, stderr, stdout;
    ({error: error$$1, stdout, stderr, status} = res);
    if (stdout != null) {
      outAll += stdout;
    }
    if (stderr != null) {
      errAll += stderr;
    }
    if (key != null) {
      return object[key] = {
        error: error$$1,
        stdout: stdout,
        stderr: stderr,
        status: status
      };
    }
  };
  done = function(err, status = 0) {
    if (err != null) {
      if (!opts.quiet) {
        console.error(err.toString());
      }
      errors.push(err);
    }
    if (--todo) {
      return;
    }
    if (errors.length) {
      err = new Error('Partial completion');
      err.errors = errors;
      status = 1;
    }
    return cb(err, outAll, errAll, status, object);
  };
  while (cmds.length) {
    cmd = cmds.shift();
    (function(cmd) {
      var err, key, val;
      if (isArray$1(cmd)) {
        [key, cmd] = cmd;
      }
      if (isString$1(cmd)) {
        cmd = cmd.replace(/\\/g, '\\\\');
        return fn(cmd, opts, function(err, stdout, stderr, status) {
          append(key, {
            error: err,
            stdout: stdout,
            stderr: stderr,
            status: status
          });
          return done(err, status);
        });
      } else if (isFunction$1(cmd)) {
        try {
          val = cmd();
          if (isPromise$1(val)) {
            return cmds.push(val);
          } else if (isString$1(val)) {
            return cmds.push(val);
          } else {
            append(key, val);
            return done(null, 0);
          }
        } catch (error1) {
          err = error1;
          return done(err);
        }
      } else if (isPromise$1(cmd)) {
        return cmd.then(function(val) {
          append(key, val);
          return done(null, 0);
        }).catch(function(err) {
          return done(err);
        });
      }
    })(cmd);
  }
};

// src/flow/serial.coffee
var serial;

// Execute commands in serial
var serial$1 = serial = function(fn, cmds, opts, cb) {
  var append, errAll, lastStatus, next, object, outAll;
  errAll = '';
  outAll = '';
  lastStatus = null;
  if (cmds.length && isArray$1(cmds[0])) {
    object = {};
  } else {
    object = null;
  }
  append = function(key, res = {}) {
    var error$$1, status, stderr, stdout;
    ({error: error$$1, stdout, stderr, status} = res);
    if (stdout != null) {
      outAll += stdout;
    }
    if (stderr != null) {
      errAll += stderr;
    }
    if (status != null) {
      lastStatus = status;
    } else {
      lastStatus = 0;
    }
    if (key != null) {
      return object[key] = {
        error: error$$1,
        stdout: stdout,
        stderr: stderr,
        status: status
      };
    }
  };
  return (next = function() {
    var cmd, err, key, val;
    if (!cmds.length) {
      return cb(null, outAll, errAll, lastStatus, object);
    }
    cmd = cmds.shift();
    if (isArray$1(cmd)) {
      [key, cmd] = cmd;
    }
    if (isString$1(cmd)) {
      cmd = cmd.replace(/\\/g, '\\\\');
      return fn(cmd, opts, function(err, stdout, stderr, status) {
        append(key, {
          error: err,
          stdout: stdout,
          stderr: stderr,
          status: status
        });
        if (opts.strict && (err != null)) {
          return cb(err, outAll, errAll, lastStatus, object);
        } else {
          return next();
        }
      });
    } else if (isPromise$1(cmd)) {
      return cmd.then(function(val) {
        append(key, val);
        return next();
      }).catch(function(err) {
        return cb(err, outAll, errAll, 1, object);
      });
    } else if (isFunction$1(cmd)) {
      try {
        val = cmd();
        if ((isPromise$1(val)) || (isString$1(val))) {
          cmds.unshift(val);
        } else {
          append(key, val);
        }
        return next();
      } catch (error1) {
        err = error1;
        return cb(err, outAll, errAll, 1, object);
      }
    } else {
      return cb(new Error(`Not a valid command: ${cmd.toString()}`));
    }
  })();
};

// src/flow/index.coffee
var array$1, object$1, string$1;

// Execute array of commands, with serial exution by default
array$1 = function(exec, cmds, opts, cb) {
  if (opts.parallel) {
    return parallel$1(exec, cmds, opts, cb);
  } else {
    return serial$1(exec, cmds, opts, cb);
  }
};

// Execute string representing commands
string$1 = function(exec, str, opts, cb) {
  var cmds, s;
  cmds = (function() {
    var i, len, ref, results;
    ref = str.split('\n');
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      s = ref[i];
      if (s.trim() !== '') {
        results.push(s);
      }
    }
    return results;
  })();
  return array$1(exec, cmds, opts, cb);
};

// Execute object of commands
object$1 = function(exec, obj, opts, cb) {
  var cmd, cmds, k;
  cmds = (function() {
    var results;
    results = [];
    for (k in obj) {
      cmd = obj[k];
      results.push([k, cmd]);
    }
    return results;
  })();
  return array$1(exec, cmds, opts, cb);
};

// Execute commands using either serial or parallel control flow and return
// result to cb
function flow(cmds, opts, cb) {
  var exec;
  // Use sync exec if necessary
  exec = opts.sync ? sync$1 : async$1;
  if (isString$1(cmds)) {
    return string$1(exec, cmds, opts, cb);
  }
  if (isObject$1(cmds)) {
    return object$1(exec, cmds, opts, cb);
  }
  if (isArray$1(cmds)) {
    return array$1(exec, cmds, opts, cb);
  }
  throw new Error(`Unable to return results for cmds = ${JSON.stringify(cmds)}`);
}

// src/executive.coffee
var async$2, promise, sync$2;

// Return executive results asynchronously
async$2 = function(cmds, opts, cb) {
  return flow(cmds, opts, function(err, stdout, stderr, status, object) {
    var obj;
    if (object != null) {
      obj = mergeResult(stdout, stderr, status, object);
      return cb(err, obj, stdout, stderr, status);
    } else {
      return cb(err, stdout, stderr, status);
    }
  });
};

// Return executive results synchronously
sync$2 = function(cmds, opts) {
  var ret;
  ret = null;
  // This happens synchronously
  flow(cmds, opts, function(err, stdout, stderr, status, object) {
    if (opts.syncThrows) {
      if (opts.strict && status !== 0) {
        throw err;
      } else if ((err != null) && (status == null)) {
        throw err;
      }
    }
    return ret = mergeResult(stdout, stderr, status, object);
  });
  return ret;
};

// Return executive results as promise
promise = function(cmds, opts) {
  return new Promise(function(resolve, reject) {
    return flow(cmds, opts, function(err, stdout, stderr, status, object) {
      if (opts.strict && status !== 0) {
        return reject(err);
      } else if ((err != null) && (status == null)) {
        return reject(err);
      }
      return resolve(mergeResult(stdout, stderr, status, object));
    });
  });
};

// Run string, array or object commands and return results
function exec(cmds, opts, cb) {
  // Passed only callback
  if (isFunction$1(opts)) {
    [cb, opts] = [opts, {}];
  }
  // Ensure opts exists
  if (opts == null) {
    opts = {};
  }
  if (isFunction$1(cb)) {
    // Async exec with errback-style callback
    return async$2(cmds, opts, cb);
  }
  if (opts.sync) {
    // Blocking exec
    return sync$2(cmds, opts);
  }
  // Async exec with Promise API expected
  return promise(cmds, opts);
}

// src/index.coffee
var partial;

// Set defaults for various helpers
partial = function(defaults) {
  return function(cmds, opts, cb) {
    if (isFunction$1(opts)) {
      [cb, opts] = [opts, {}];
    }
    return exec(cmds, Object.assign({}, defaults, opts), cb);
  };
};

// Defaults
exec.interactive = partial({
  interactive: true
});

exec.parallel = partial({
  parallel: true
});

exec.quiet = partial({
  quiet: true
});

exec.serial = partial({
  parallel: false
});

exec.strict = partial({
  strict: true
});

exec.sync = partial({
  sync: true
});

module.exports = exec;
//# sourceMappingURL=executive.cjs.js.map
