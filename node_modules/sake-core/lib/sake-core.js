'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var chalk = _interopDefault(require('chalk'));
var resolve = _interopDefault(require('resolve'));
var vigil = _interopDefault(require('vigil'));
var exec = _interopDefault(require('executive'));
var path = require('path');

// node_modules/es-tostring/index.mjs
function toString(obj) {
  return Object.prototype.toString.call(obj)
}

// node_modules/es-is/array.js
// Generated by CoffeeScript 1.12.5
var isArray;

var isArray$1 = isArray = Array.isArray || function(value) {
  return toString(value) === '[object Array]';
};

// node_modules/es-is/function.js
// Generated by CoffeeScript 1.12.5
var isFunction;

var isFunction$1 = isFunction = function(value) {
  var str;
  if (typeof window !== 'undefined' && value === window.alert) {
    return true;
  }
  str = toString(value);
  return str === '[object Function]' || str === '[object GeneratorFunction]' || str === '[object AsyncFunction]';
};

// node_modules/es-is/string.js
// Generated by CoffeeScript 1.12.5
var isString;

var isString$1 = isString = function(value) {
  return toString(value) === '[object String]';
};

// src/log.coffee
var k, logger, methods, pretty, ref, v, verbose, wrapper,
  slice = [].slice;

verbose = (ref = process.env.VERBOSE) != null ? ref : false;

pretty = function(obj) {
  return JSON.stringify(obj, null, 2);
};

logger = function(method, color) {
  var prefix;
  prefix = chalk[color](method);
  return function() {
    var arg, args, i, len, msg;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (!verbose) {
      return;
    }
    msg = prefix;
    for (i = 0, len = args.length; i < len; i++) {
      arg = args[i];
      if (isString$1(arg)) {
        msg += ' ' + arg;
      } else {
        msg += '\n' + pretty(arg);
      }
    }
    return console.log(msg);
  };
};

methods = {
  debug: 'blue',
  info: 'white',
  warn: 'yellow',
  error: 'red',
  bebop: 'black',
  modified: 'cyan',
  compiled: 'blue'
};

wrapper = logger('info', 'white');

for (k in methods) {
  v = methods[k];
  wrapper[k] = logger(k, v);
}

wrapper.verbose = function(bool) {
  if (bool == null) {
    bool = !verbose;
  }
  return verbose = bool;
};

var log = wrapper;

// node_modules/es-is/generator-function.js
// Generated by CoffeeScript 1.12.5
var isGeneratorFunction;

var isGeneratorFunction$1 = isGeneratorFunction = function(value) {
  return toString(value) === '[object GeneratorFunction]';
};

// src/tasks.coffee
var tasks;

tasks = {};

tasks.has = function(key) {
  return tasks[key] != null;
};

var tasks$1 = tasks;

// src/running.coffee
var running, runningTasks;

runningTasks = {};

running = function(name) {
  return runningTasks[name];
};

running.start = function(name) {
  log.info('running', name);
  return runningTasks[name] = true;
};

running.stop = function(name) {
  log.info('stopped', name);
  return runningTasks[name] = false;
};

var running$1 = running;

// src/invoke/async.coffee
var invokeAsync;

invokeAsync = function(name, action, opts, cb) {
  var done;
  log.debug('invokeAsync', name);
  running$1.start(name);
  done = function() {
    running$1.stop(name);
    return cb.apply(null, arguments);
  };
  if (opts != null) {
    return action(opts, done);
  } else {
    return action(done);
  }
};

var invokeAsync$1 = invokeAsync;

// node_modules/es-is/promise.js
// Generated by CoffeeScript 1.12.5
var isPromise;

var isPromise$1 = isPromise = function(value) {
  return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';
};

// src/invoke/generator.coffee
var invokeGenerator;

invokeGenerator = function(name, action, opts, cb) {
  var done, gen, last, next, prev;
  log.debug('invokeGenerator', name);
  running$1.start(name);
  gen = action(opts);
  last = null;
  prev = null;
  done = function(err) {
    running$1.stop(name);
    if (err != null) {
      console.error(err.stack);
    }
    return cb(err, last != null ? last : prev);
  };
  next = function(value) {
    var err, promise, res;
    try {
      res = gen.next(value);
    } catch (error) {
      err = error;
      console.error(err.stack);
      return done(err);
    }
    prev = last;
    last = res.value;
    if (isPromise$1(promise = res.value)) {
      return promise.then(function(value) {
        return next(value);
      })["catch"](function(err) {
        return done(err);
      });
    } else if (!res.done) {
      return next(res.value);
    } else {
      return done();
    }
  };
  return next();
};

var invokeGenerator$1 = invokeGenerator;

// src/invoke/sync.coffee
var invokeSync;

invokeSync = function(name, action, opts, cb) {
  var promise, ret;
  log.debug('invokeSync', name);
  running$1.start(name);
  ret = action(opts);
  if (isPromise$1(promise = ret)) {
    return promise.then(function(value) {
      running$1.stop(name);
      return cb(null, value);
    })["catch"](function(err) {
      running$1.stop(name);
      return cb(err);
    });
  } else {
    running$1.stop(name);
    return cb(null, ret);
  }
};

var invokeSync$1 = invokeSync;

// src/invoke/serial.coffee
var invokeSerial;

invokeSerial = function(tasks, opts, cb) {
  var serial;
  log.debug('invokeSerial', tasks, opts);
  serial = function(cb) {
    var next;
    next = function(err) {
      if (err != null) {
        return cb(err);
      }
      if (tasks.length) {
        return invoke$2(tasks.shift(), opts, next);
      } else {
        return cb();
      }
    };
    return next();
  };
  if (isFunction$1(cb)) {
    return serial(cb);
  }
  return new Promise(function(resolve$$1, reject) {
    return serial(function(err) {
      if (err != null) {
        reject(err);
      }
      resolve$$1();
      if (isFunction$1(cb)) {
        return cb(err);
      }
    });
  });
};

var serial = invokeSerial;

// src/invoke/invoke.coffee
var invoke$1, invoked;

invoked = {};

invoke$1 = function(name, opts, cb) {
  var action, deps, done, invokeAction, ref, task;
  log.debug('invoke', name, opts);
  if (invoked[name]) {
    return;
  }
  invoked[name] = true;
  if ((task = tasks$1[name]) == null) {
    throw new Error("No such task: " + name);
  }
  ref = tasks$1[name], action = ref.action, deps = ref.deps;
  done = function(err) {
    invoked = {};
    if (isFunction$1(cb)) {
      return cb(err);
    }
  };
  invokeAction = function(err) {
    if (err != null) {
      return done(err);
    }
    if (isGeneratorFunction$1(action)) {
      return invokeGenerator$1(name, action, opts, done);
    }
    if (action.length === 2) {
      return invokeAsync$1(name, action, opts, done);
    }
    if (/^function \((callback|cb|done|next)\)/.test(action)) {
      return invokeAsync$1(name, action, null, done);
    }
    return invokeSync$1(name, action, opts, done);
  };
  return serial(deps, opts, invokeAction);
  return invokeAction();
};

var invoke$2 = invoke$1;

// src/invoke/parallel.coffee
var invokeParallel;

invokeParallel = function(tasks, opts, cb) {
  var parallel;
  log.debug('invokeParallel', tasks, opts);
  parallel = function(cb) {
    var done, i, len, results, task;
    done = 0;
    results = [];
    for (i = 0, len = tasks.length; i < len; i++) {
      task = tasks[i];
      results.push(invoke$2(task, opts, function() {
        if (++done === tasks.length) {
          return cb();
        }
      }));
    }
    return results;
  };
  if (isFunction$1(cb)) {
    return parallel(cb);
  }
  return new Promise(function(resolve$$1, reject) {
    return parallel(function(err) {
      if (err != null) {
        reject(err);
      }
      resolve$$1();
      if (isFunction$1(cb)) {
        return cb(err);
      }
    });
  });
};

var parallel = invokeParallel;

// src/invoke/index.coffee
var wrap, wrapper$1;

wrap = function(fn) {
  return function(tasks, opts, cb) {
    var ref;
    if (!isArray$1(tasks)) {
      tasks = [tasks];
    }
    if (isFunction$1(opts)) {
      ref = [opts, {}], cb = ref[0], opts = ref[1];
    }
    if (opts == null) {
      opts = {};
    }
    return fn(tasks, opts, cb);
  };
};

wrapper$1 = wrap(serial);

wrapper$1.serial = wrapper$1;

wrapper$1.parallel = wrap(parallel);

var invoke$3 = wrapper$1;

// src/options.coffee
var options;

options = {};

options.has = function(key) {
  return options[key] != null;
};

var options$1 = options;

// src/option.coffee

function option(letter, flag, description) {
  var ref;
  if (description == null) {
    ref = [flag, null], description = ref[0], flag = ref[1];
  }
  return options$1[letter] = {
    letter: letter,
    flag: flag,
    description: description
  };
}

// src/task.coffee

function task(name, description, deps, action) {
  var ref, ref1, ref2;
  if (isArray$1(description)) {
    if (isFunction$1(deps)) {
      action = deps;
    }
    ref = ['', description], description = ref[0], deps = ref[1];
  }
  if (isFunction$1(description)) {
    ref1 = [description, '', []], action = ref1[0], description = ref1[1], deps = ref1[2];
  }
  if (isFunction$1(deps)) {
    ref2 = [deps, []], action = ref2[0], deps = ref2[1];
  }
  if (!isFunction$1(action)) {
    action = function() {};
  }
  tasks$1[name] = {
    name: name,
    description: description,
    deps: deps,
    action: action
  };
  return log.debug('added task', tasks$1[name]);
}

// src/use.coffee

function use(pkg, opts) {
  var path$$1;
  if (opts == null) {
    opts = {};
  }
  if (isString$1(pkg)) {
    path$$1 = resolve.sync(pkg, {
      basedir: process.cwd()
    });
    pkg = require(path$$1);
    if (pkg["default"] != null) {
      pkg = pkg["default"];
    }
  }
  if (isFunction$1(pkg)) {
    return pkg(opts);
  }
}

// src/watch.coffee

function watch(dir, task, opts) {
  var fn;
  if (opts == null) {
    opts = {};
  }
  if (isString$1(task)) {
    fn = function() {
      return invoke(task);
    };
  } else if (isFunction$1(task)) {
    fn = task;
  }
  return vigil.watch(dir, fn, opts);
}

// package.json
var version = "1.6.7";

// src/sake.coffee


exports.install = function() {
  var binPath;
  binPath = path.join(process.cwd(), 'node_modules/', '.bin');
  process.env.PATH = ([binPath].concat(process.env.PATH.split(':'))).join(':');
  global.invoke = invoke$3;
  global.option = option;
  global.options = options$1;
  global.running = running$1;
  global.task = task;
  global.tasks = tasks$1;
  global.use = use;
  global.watch = watch;
  return global.exec = exec;
};


var sake = Object.freeze({
	get install () { return exports.install; },
	invoke: invoke$3,
	option: option,
	options: options$1,
	parallel: parallel,
	running: running$1,
	serial: serial,
	task: task,
	tasks: tasks$1,
	use: use,
	version: version,
	watch: watch
});

// src/index.coffee

exports.default = sake;
exports.version = version;
exports.invoke = invoke$3;
exports.option = option;
exports.options = options$1;
exports.parallel = parallel;
exports.running = running$1;
exports.serial = serial;
exports.task = task;
exports.tasks = tasks$1;
exports.use = use;
exports.watch = watch;
//# sourceMappingURL=sake-core.js.map
