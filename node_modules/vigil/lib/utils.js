// Generated by CoffeeScript 1.11.1
var defaultExcludeRe, defaultIncludeRe, fs, getcb, n, path, ref, ref1, ref2, splitPattern, tmpDir, tmpName, toRegExp;

fs = require('fs');

path = require('path');

toRegExp = require('to-regexp');

tmpDir = (ref = (ref1 = (ref2 = process.env.TMPDIR) != null ? ref2 : process.env.TMP) != null ? ref1 : process.env.TEMP) != null ? ref : '/tmp';

exports.excludeRe = defaultExcludeRe = /^\.|node_modules|npm-debug.log$|Cakefile|\.txt$|package.json$|\.map$|\.DS_Store/;

exports.includeRe = defaultIncludeRe = /^\S/;

tmpName = function(prefix, cb, tries) {
  var filename;
  if (tries == null) {
    tries = 0;
  }
  if (tries > 5) {
    return cb(new Error('max tries exceeded'));
  }
  filename = path.join(tmpDir, prefix + "-" + ((Math.random() * 0x1000000000).toString(36)));
  return fs.exists(filename, function(exists) {
    if (exists) {
      return tmpName(cb, tries + 1);
    } else {
      return cb(null, filename);
    }
  });
};

exports.tmpFile = function(prefix, cb) {
  return tmpName(prefix, function(err, filename) {
    if (err != null) {
      return cb(err);
    }
    return fs.open(filename, 'wx+', function(err, fd) {
      var cleanup;
      if (err != null) {
        return cb(err);
      }
      cb(null, filename, fd);
      cleanup = function() {
        return fs.unlinkSync(filename);
      };
      process.addListener('uncaughtException', cleanup);
      return process.addListener('exit', cleanup);
    });
  });
};

splitPattern = function(pattern) {
  var basePath, findBasePath, isGlob;
  isGlob = function(s) {
    return /[*?]/.exec(s);
  };
  findBasePath = function(pattern) {
    var basePaths, j, len, p, paths;
    paths = pattern.split('/');
    basePaths = [];
    for (j = 0, len = paths.length; j < len; j++) {
      p = paths[j];
      if (isGlob(p)) {
        break;
      } else {
        basePaths.push(p);
      }
    }
    return basePaths.join('/');
  };
  basePath = findBasePath(pattern);
  pattern = pattern.replace(basePath, '');
  return [basePath, pattern];
};

exports.parseArgs = function(fn) {
  return function(pattern, opts, cb) {
    var basePath, err, excludeRe, excluded, home, includeRe, maybeGlobby, ref3, ref4, ref5, ref6, ref7, ref8, regex, relative;
    if (typeof opts === 'function') {
      ref3 = [{}, opts], opts = ref3[0], cb = ref3[1];
    }
    ref4 = splitPattern(pattern), basePath = ref4[0], maybeGlobby = ref4[1];
    if ((basePath.charAt(0)) === '~') {
      home = (ref5 = (ref6 = process.env.HOME) != null ? ref6 : process.env.HOMEPATH) != null ? ref5 : process.env.USERPROFILE;
      basePath = path.join(home, dir.substring(2));
    }
    basePath = path.resolve(basePath);
    relative = function(filename) {
      if ((filename.indexOf(basePath)) === 0) {
        return (filename.substring(basePath.length)).replace(/^\//, '');
      } else {
        return filename;
      }
    };
    if (maybeGlobby) {
      regex = toRegExp(maybeGlobby);
      excluded = function(filename) {
        if (regex.test(filename)) {
          return false;
        } else {
          return true;
        }
      };
      opts.relative = relative;
      opts.excluded = excluded;
      return fn(basePath, opts, cb);
    }
    try {
      excludeRe = toRegExp((ref7 = opts.exclude) != null ? ref7 : defaultExcludeRe);
      includeRe = toRegExp((ref8 = opts.include) != null ? ref8 : defaultIncludeRe);
    } catch (error) {
      err = error;
      return cb(err);
    }
    excluded = function(filename) {
      var relname;
      relname = relative(filename);
      if (includeRe != null) {
        if (!includeRe.test(relname)) {
          return true;
        }
      }
      if (excludeRe != null) {
        if (excludeRe.test(relname)) {
          return true;
        }
      }
    };
    opts.relative = relative;
    opts.excluded = excluded;
    return fn(basePath, opts, cb);
  };
};

getcb = function(args) {
  var arg, cb, i, j, len;
  for (i = j = 0, len = args.length; j < len; i = ++j) {
    arg = args[i];
    if (typeof arg === 'function') {
      cb = args.splice(i, 1);
      return [cb, i];
    }
  }
  return [null, -1];
};

n = 0;

exports.debounce = function(timeout, fn) {
  var running;
  running = {};
  return function() {
    var args, cb, done, i, key, ref3, start;
    start = new Date();
    args = [].slice.call(arguments);
    key = JSON.stringify(args);
    if (running[key] != null) {
      return;
    }
    running[key] = true;
    ref3 = getcb(args), cb = ref3[0], i = ref3[1];
    done = function() {
      var diff, end, wait;
      end = new Date();
      diff = end - start;
      if (diff > timeout) {
        return delete running[key];
      } else {
        wait = timeout - diff;
        return setTimeout(function() {
          return delete running[key];
        }, wait);
      }
    };
    if (cb != null) {
      args.splice(i, 0, function() {
        cb.apply(null, arguments);
        return done();
      });
    }
    fn.apply(null, args);
    if (cb == null) {
      return done();
    }
  };
};

//# sourceMappingURL=utils.js.map
